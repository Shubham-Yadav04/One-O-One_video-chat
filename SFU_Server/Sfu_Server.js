 
import pkg from "wrtc";
import io from "socket.io-client";

const { RTCPeerConnection ,RTCSessionDescription} = pkg;
const sfu = io("http://localhost:8000", {
  reconnection: true,
  reconnectionAttempts: Infinity,
  reconnectionDelay: 2000
});

sfu.on("connect", () => {
 
  sfu.emit("sfu-server"); 
   console.log("Connected to SFU");
});

sfu.on("disconnect", () => {
  console.log("SFU disconnected, will retry automatically...");
});
// roomId -> { socketId -> { pc: RTCPeerConnection ,published:{audio,video},senders:[] }} // senders me wo log honge jo jinke behje hue tracks isse apne px me add krke sunne honge 
const roomToUser = new Map(); // local cache ki trh chalega jb tk server chalega
// ---- Handle new user joining a room ----
sfu.on("user-joined-room", async ({ roomId, email, socketId, offer,sessionId}) => {
  console.log(`${email} joined room ${roomId}`);

  // Create PeerConnection for this client
  const pc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
  }); 
  pc.addTransceiver('audio', { direction: 'recvonly' });
pc.addTransceiver('video', { direction: 'recvonly' });

   if (!roomToUser.has(roomId)) roomToUser.set(roomId, new Map());
  roomToUser.get(roomId).set(socketId, { pc, published: { audio: null, video: null }, senders: [] });
  // setupNegotiation(pc, socketId, roomId);

  // Handle ICE candidates generated by SFU
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      sfu.emit("sfu-ice-candidate", {
        roomId,
        socketId,
        candidate: event.candidate,
      });
    } 
  };
 await pc.setRemoteDescription(new RTCSessionDescription(offer));

 const buffered = (pendingCandidates[roomId] || {})[socketId] || [];
for (const c of buffered) {
  try { await pc.addIceCandidate(c); } catch(e){ console.warn(e); }
}
pendingCandidates[roomId][socketId] = [];
  // Create answer  
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
 subscribeNewUserToExisting(roomId, socketId);
  // Send answer back to signaling -> client
  sfu.emit("sfu-answer", { socketId, answer:pc.localDescription, email, roomId,sessionId });

pc.ontrack = (event) => {
  const stream = event.streams[0];
  const kind = event.track.kind; // "audio" | "video"
  const room = roomToUser.get(roomId);
  const user = room.get(socketId);
  user.published ??= { audio: null, video: null };
  user.published[kind] = event.track;

  // Forward this *new* publisher's track to everyone else
   
forwardTrackToOthers(roomId, socketId, kind, event.track);
    
   stream.onremovetrack = (e) => {
    console.log(`Publisher ${socketId} removed ${e.track.kind}`);
    removeTrackFromOthers(roomId, socketId, e.track);
  };
};
 
});

// ---- Handle ICE candidates from client ----
sfu.on("ice-candidate", async ({ roomId, socketId, candidate }) => {
  const user = roomToUser.get(roomId)?.get(socketId);
  if (!user) {
    // buffer candidate
    if (!pendingCandidates[roomId]) pendingCandidates[roomId] = {};
    pendingCandidates[roomId][socketId] ??= [];
    pendingCandidates[roomId][socketId].push(candidate);
    return;
  }
  try {
    await user.pc.addIceCandidate(candidate);
  } catch (err) { console.error(err); }
});

 
sfu.on('client-renegotiate-offer', async ({ roomId, socketId, offer }) => {
  const userPeer = roomToUser.get(roomId)?.get(socketId);
  if (!userPeer) return;

  try { 
    // If we already have a local offer, we must rollback then apply remote offer
    if (userPeer.pc.signalingState === "have-local-offer") {
      console.log("Glare detected: rolling back local offer");
      // rollback our local description
      await userPeer.pc.setLocalDescription({ type: "rollback" });
      // after rollback we should be in 'stable' â€” now proceed to apply remote offer
    }

    // Apply remote offer and create an answer
    await userPeer.pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await userPeer.pc.createAnswer();
    await userPeer.pc.setLocalDescription(answer);

    // send back the answer to signalling so it can forward to client
    sfu.emit('client-renegotiation-answer-by-sfu', {
      renegotiateAnswer: userPeer.pc.localDescription,
      roomId,
      socketId
    });

    console.log("Renegotiation handled with client offer");
  } catch (err) {
    console.error("Error handling client renegotiation offer:", err);
  }
});

sfu.on('sfu-renegotiate-answer-by-client',async({roomId, socketId, answer })=>{
  //find the pc  
  const userPeer = roomToUser.get(roomId)?.get(socketId);
  if (!userPeer) return;

  try {
    await userPeer.pc.setRemoteDescription(new RTCSessionDescription(answer));
    console.log('Renegotiation answer applied');
  } catch (err) {
    console.error("Error setting renegotiation answer:", err);
  }
}) 
// ---- Forward tracks between clients ----
function forwardTrackToOthers(roomId, senderSocketId, kind, track) {
  const room = roomToUser.get(roomId);

  room.forEach((targetUser, targetSocketId) => {
    if (targetSocketId === senderSocketId)return ;

    // Avoid duplicates: only add if not already sending this exact track
    const already = (targetUser.senders || []).some(s => s.track && s.track.id === track.id);
    if (!already) {
      const sender = targetUser.pc.addTrack(track);
      trackBind(roomId, targetSocketId, sender); // using it to save the sender detail in the senders array of the current socket id or user 
      forceRenegotiate(targetUser.pc, targetSocketId, roomId);
       
    }
  }
  );
}

function trackBind(roomId, socketId, sender) {
  const room = roomToUser.get(roomId);
  const user = room.get(socketId);
  user.senders ??= [];
  user.senders.push(sender);
}

function removeTrackFromOthers(roomId, senderSocketId, track) {
  const room = roomToUser.get(roomId);
  room.forEach((user, socketId) => {
    if (socketId === senderSocketId) return;

    user.senders ??= [];
    const sender = user.senders.find(s => s.track && s.track.id === track.id);

    if (sender) {
      console.log(`Removing ${track.kind} track from subscriber ${socketId}`);

      try {
        user.pc.removeTrack(sender);
      } catch (err) {
        console.error("removeTrack failed:", err);
      }
      // Keep sender list clean
      user.senders = user.senders.filter(s => s !== sender);

      // Trigger renegotiation with this subscriber
      forceRenegotiate(user.pc, socketId, roomId);
    }
  });
}

//  function setupNegotiation(pc, socketId, roomId) {
//   pc.onnegotiationneeded = async () => {
//     try {
//       const offer = await pc.createOffer();
//       await pc.setLocalDescription(new RTCSessionDescription(offer));

//       // Send offer to client for renegotiation
//       sfu.emit("sfu-renegotiation-offer", {
//         socketId,
//         roomId,
//         offer: pc.localDescription,
//       });
//     } catch (err) {
//       console.error("Negotiation error:", err);
//     }
//   };
// } 
function subscribeNewUserToExisting(roomId, newSocketId) {
  console.log("connected to the exixting user");
  const room = roomToUser.get(roomId);
  const newUser = room.get(newSocketId);

  room.forEach((otherUser, otherSocketId) => {
    if (otherSocketId === newSocketId) return;
    // For each published track (audio/video) add to the new user's pc
    for (const kind of ["audio", "video"]) {
      const track = otherUser.published?.[kind];
      if (track) {
        const sender = newUser.pc.addTrack(track);
        trackBind(roomId, newSocketId, sender); // save sender for later removal
      }
    }
  });

  forceRenegotiate(newUser.pc, newSocketId, roomId);
}

async function forceRenegotiate(pc, socketId, roomId) {
  if (pc.signalingState !== "stable") {
    console.warn(`Skip renegotiation for ${socketId}, state=${pc.signalingState}`);
    return;
  }
  try {
    const offer = await pc.createOffer();
    await pc.setLocalDescription(new RTCSessionDescription(offer));
    sfu.emit("sfu-renegotiation-offer", { socketId, roomId, offer: pc.localDescription });
  } catch (e) {
    console.error("forceRenegotiate failed:", e);
  }

}


function handleUserLeave(roomId, socketId) {
  const room = roomToUser.get(roomId);
  const user = room?.get(socketId);

  if (!user) return;

  console.log(`Cleaning up user ${socketId}`);

  // Remove all published tracks from others
  for (const kind of ["audio", "video"]) {
    const track = user.published?.[kind];
    if (track) {
      removeTrackFromOthers(roomId, socketId, track);
      track.stop(); // stop the track completely
    }
  }

  // Close their RTCPeerConnection
  try {
    user.pc.close();
  } catch (e) {
    console.warn("Error closing pc:", e);
  }

  room.delete(socketId);
  if (room.size === 0) roomToUser.delete(roomId);
}


